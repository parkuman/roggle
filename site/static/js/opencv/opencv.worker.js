/* eslint-disable no-undef */
/**
 * This file is a Web Worker Responsible for loading and
 * running OpenCV commands off the main thread
 */

const paths = {
	wasm: "./wasm/opencv.js",
	threads: "./threads/opencv.js",
	simd: "./wasm/opencv.js", // TODO: use SIMD
	threadsSimd: "./threads_simd/opencv.js"
};

/**
 *  This is the code mostly generated by OpenCV for loading depending on what
 *  wasm features are enabled in the browser, just moved to a function inside here.
 *
 * @returns the path to the correct opencv script to use depending on the current browser's features
 */
async function getOpenCV() {
	let OPENCV_URL = "";
	let wasmPath = "";
	let simdPath = "";
	let threadsPath = "";
	let threadsSimdPath = "";

	if ("wasm" in paths) {
		wasmPath = paths["wasm"];
	}

	if ("threads" in paths) {
		threadsPath = paths["threads"];
	}

	if ("simd" in paths) {
		simdPath = paths["simd"];
	}

	if ("threadsSimd" in paths) {
		threadsSimdPath = paths["threadsSimd"];
	}

	let wasmSupported = !(typeof WebAssembly === "undefined");
	if (!wasmSupported) {
		throw new Error("The browser doesn't support WebAssembly, cannot load OpenCV");
	}

	let simdSupported = wasmSupported ? await wasmFeatureDetect.simd() : false;
	let threadsSupported = wasmSupported ? await wasmFeatureDetect.threads() : false;

	if (simdSupported && threadsSupported && threadsSimdPath != "") {
		OPENCV_URL = threadsSimdPath;
		console.log("The OpenCV.js with simd and threads optimization is loaded now");
	} else if (simdSupported && simdPath != "") {
		if (threadsSupported && threadsSimdPath === "") {
			console.log(
				"The browser supports simd and threads, but the path of OpenCV.js with simd and threads optimization is empty"
			);
		}
		OPENCV_URL = simdPath;
		console.log("The OpenCV.js with simd optimization is loaded now.");
	} else if (threadsSupported && threadsPath != "") {
		if (simdSupported && threadsSimdPath === "") {
			console.log(
				"The browser supports simd and threads, but the path of OpenCV.js with simd and threads optimization is empty"
			);
		}
		OPENCV_URL = threadsPath;
		console.log("The OpenCV.js with threads optimization is loaded now");
	} else if (wasmSupported && wasmPath != "") {
		if (simdSupported && threadsSupported) {
			console.log(
				"The browser supports simd and threads, but the path of OpenCV.js with simd and threads optimization is empty"
			);
		}

		if (simdSupported) {
			console.log(
				"The browser supports simd optimization, but the path of OpenCV.js with simd optimization is empty"
			);
		}

		if (threadsSupported) {
			console.log(
				"The browser supports threads optimization, but the path of OpenCV.js with threads optimization is empty"
			);
		}

		OPENCV_URL = wasmPath;
		console.log("The OpenCV.js for wasm is loaded now");
	} else if (wasmSupported) {
		console.log("The browser supports wasm, but the path of OpenCV.js for wasm is empty");
	}

	if (OPENCV_URL === "") {
		throw new Error("No available OpenCV.js, please check your paths");
	}

	return OPENCV_URL;
}

/**
 *  Here we will check from time to time if we can access the OpenCV
 *  functions. We will return in a callback if it's been resolved
 *  well (true) or if there has been a timeout (false).
 */
function waitForOpencv(callbackFn, waitTimeMs = 30000, stepTimeMs = 100) {
	if (cv.Mat) callbackFn(true);

	let timeSpentMs = 0;
	const interval = setInterval(() => {
		const limitReached = timeSpentMs > waitTimeMs;
		if (cv.Mat || limitReached) {
			clearInterval(interval);
			return callbackFn(!limitReached);
		} else {
			timeSpentMs += stepTimeMs;
		}
	}, stepTimeMs);
}

function imageProcessing({ msg, payload }) {
	const img = cv.matFromImageData(payload);
	let result = new cv.Mat();

	// This converts the image to a greyscale.
	cv.cvtColor(img, result, cv.COLOR_BGR2GRAY);
	postMessage({ msg, payload: imageDataFromMat(result) });
}

/**
 * This function converts again from cv.Mat to ImageData
 */
function imageDataFromMat(mat) {
	// converts the mat type to cv.CV_8U
	const img = new cv.Mat();
	const depth = mat.type() % 8;
	const scale = depth <= cv.CV_8S ? 1.0 : depth <= cv.CV_32S ? 1.0 / 256.0 : 255.0;
	const shift = depth === cv.CV_8S || depth === cv.CV_16S ? 128.0 : 0.0;
	mat.convertTo(img, cv.CV_8U, scale, shift);

	// converts the img type to cv.CV_8UC4
	switch (img.type()) {
		case cv.CV_8UC1:
			cv.cvtColor(img, img, cv.COLOR_GRAY2RGBA);
			break;
		case cv.CV_8UC3:
			cv.cvtColor(img, img, cv.COLOR_RGB2RGBA);
			break;
		case cv.CV_8UC4:
			break;
		default:
			throw new Error("Bad number of channels (Source image must have 1, 3 or 4 channels)");
	}
	const clampedArray = new ImageData(new Uint8ClampedArray(img.data), img.cols, img.rows);
	img.delete();
	return clampedArray;
}

/**
 * This exists to capture all the events that are thrown out of the worker
 * into the worker. Without this, there would be no communication possible
 * with the project.
 */
onmessage = async function (e) {
	switch (e.data.msg) {
		case "load": {
			try {
				self.importScripts("./wasm-feature-detect.js");
				const opencvScript = await getOpenCV();
				self.importScripts(opencvScript);

				cv = await cv; // await the promise
			} catch (err) {
				throw new Error(err);
			}
			waitForOpencv(function (success) {
				if (success) postMessage({ msg: e.data.msg });
				else throw new Error("Error loading OpenCV! Time limit expired", cv);
			});
			break;
		}
		case "imageProcessing":
			return imageProcessing(e.data);
		default:
			break;
	}
};
